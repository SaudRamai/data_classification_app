-- 008_scheduling.sql
-- Stored procedure and TASK to generate dynamic compliance reports on a schedule
-- Edit the TASK warehouse below before running.

USE DATABASE IDENTIFIER($DATABASE);

CREATE SCHEMA IF NOT EXISTS DATA_GOVERNANCE;

-- Stored Procedure: Generate Dynamic Compliance Reports
CREATE OR REPLACE PROCEDURE DATA_GOVERNANCE.GEN_DYNAMIC_COMPLIANCE_REPORTS()
RETURNS STRING
LANGUAGE JAVASCRIPT
EXECUTE AS CALLER
AS
$$
// Helper to execute SQL
function exec(sql, binds) {
  var stmt = snowflake.createStatement({sqlText: sql, binds: binds || []});
  try { stmt.execute(); } catch (e) { throw e; }
}

// Current database in context
var dbq = "SELECT CURRENT_DATABASE() AS DB";
var cur = snowflake.createStatement({sqlText: dbq}).execute();
cur.next();
var DB = cur.getColumnValue('DB');

// Asset Policy View (APV) temp table
var apv = `
CREATE OR REPLACE TEMP TABLE APV AS
WITH tags AS (
  SELECT 
    UPPER(OBJECT_DATABASE)||'.'||UPPER(OBJECT_SCHEMA)||'.'||UPPER(OBJECT_NAME) AS FULL_NAME,
    MAX(CASE WHEN TAG_NAME = 'DATA_CLASSIFICATION' THEN TAG_VALUE END) AS LABEL,
    TRY_TO_NUMBER(MAX(CASE WHEN TAG_NAME = 'CONFIDENTIALITY_LEVEL' THEN TAG_VALUE END)) AS C,
    TRY_TO_NUMBER(MAX(CASE WHEN TAG_NAME = 'INTEGRITY_LEVEL' THEN TAG_VALUE END)) AS I,
    TRY_TO_NUMBER(MAX(CASE WHEN TAG_NAME = 'AVAILABILITY_LEVEL' THEN TAG_VALUE END)) AS A
  FROM SNOWFLAKE.ACCOUNT_USAGE.TAG_REFERENCES
  WHERE OBJECT_DATABASE = '" + DB + "'
  GROUP BY 1
), pol AS (
  SELECT 
    UPPER(OBJECT_DATABASE)||'.'||UPPER(OBJECT_SCHEMA)||'.'||UPPER(OBJECT_NAME) AS FULL_NAME,
    MAX(CASE WHEN POLICY_KIND='MASKING POLICY' THEN 1 ELSE 0 END) AS HAS_MASKING_POLICY,
    MAX(CASE WHEN POLICY_KIND='ROW ACCESS POLICY' THEN 1 ELSE 0 END) AS HAS_ROW_ACCESS_POLICY
  FROM SNOWFLAKE.ACCOUNT_USAGE.POLICY_REFERENCES
  WHERE OBJECT_DATABASE = '" + DB + "'
  GROUP BY 1
), cats AS (
  SELECT 
    UPPER(ASSET_FULL_NAME) AS FULL_NAME,
    ARRAY_AGG_DISTINCT(UPPER(value)::STRING) WITHIN GROUP (ORDER BY value) AS CATEGORIES
  FROM (
    SELECT ASSET_FULL_NAME, SENSITIVE_CATEGORIES AS ARR
    FROM " + DB + ".CLASSIFICATION_HISTORY.CLASSIFICATION_HISTORY
    WHERE SENSITIVE_CATEGORIES IS NOT NULL
  ), LATERAL FLATTEN(input => ARR)
  GROUP BY 1
)
SELECT 
  COALESCE(tags.FULL_NAME, pol.FULL_NAME, cats.FULL_NAME) AS FULL_NAME,
  NVL(tags.LABEL,'Internal') AS LABEL,
  NVL(tags.C,0) AS C,
  NVL(tags.I,0) AS I,
  NVL(tags.A,0) AS A,
  NVL(pol.HAS_MASKING_POLICY,0) AS HAS_MASKING_POLICY,
  NVL(pol.HAS_ROW_ACCESS_POLICY,0) AS HAS_ROW_ACCESS_POLICY,
  NVL(cats.CATEGORIES, ARRAY_CONSTRUCT()) AS CATEGORIES
FROM tags
FULL OUTER JOIN pol USING(FULL_NAME)
FULL OUTER JOIN cats USING(FULL_NAME)`;
exec(apv);

// Insert Violations (per asset per framework where any policy requirement fails)
var insViol = `
INSERT INTO " + DB + ".DATA_GOVERNANCE.VIOLATIONS
(ID, RULE_CODE, SEVERITY, DESCRIPTION, ASSET_FULL_NAME, DETECTED_AT, STATUS, DETAILS)
SELECT 
  UUID_STRING() AS ID,
  'FW:'||fw.NAME AS RULE_CODE,
  'High' AS SEVERITY,
  'Non-compliant with '||fw.NAME||' requirements' AS DESCRIPTION,
  a.FULL_NAME,
  CURRENT_TIMESTAMP,
  'Open' AS STATUS,
  OBJECT_CONSTRUCT('categories', a.CATEGORIES, 'C', a.C, 'failed', ARRAY_CONSTRUCT_COMPACT(
    CASE WHEN a.C < p.MIN_CONFIDENTIALITY THEN 'C<'||TO_VARCHAR(p.MIN_CONFIDENTIALITY) END,
    CASE WHEN p.REQUIRE_MASKING AND a.HAS_MASKING_POLICY=0 THEN 'masking' END,
    CASE WHEN p.REQUIRE_ROW_ACCESS AND a.HAS_ROW_ACCESS_POLICY=0 THEN 'row_access' END
  )) AS DETAILS
FROM APV a
JOIN " + DB + ".DATA_GOVERNANCE.FRAMEWORKS fw ON 1=1
LEFT JOIN LATERAL FLATTEN(input => a.CATEGORIES) c ON TRUE
JOIN " + DB + ".DATA_GOVERNANCE.POLICIES p
  ON UPPER(p.FRAMEWORK)=UPPER(fw.NAME) AND UPPER(p.CATEGORY)=c.value::STRING
WHERE (a.C < COALESCE(p.MIN_CONFIDENTIALITY,0)
       OR (p.REQUIRE_MASKING AND a.HAS_MASKING_POLICY=0)
       OR (p.REQUIRE_ROW_ACCESS AND a.HAS_ROW_ACCESS_POLICY=0))`;
exec(insViol);

// Insert Reports (metrics per framework)
var insReports = `
INSERT INTO " + DB + ".DATA_GOVERNANCE.COMPLIANCE_REPORTS
(ID, FRAMEWORK, GENERATED_AT, GENERATED_BY, METRICS, LOCATION)
SELECT 
  UUID_STRING() AS ID,
  fw.NAME AS FRAMEWORK,
  CURRENT_TIMESTAMP AS GENERATED_AT,
  'TASK/SP' AS GENERATED_BY,
  OBJECT_CONSTRUCT(
    'framework', fw.NAME,
    'total_assets', COUNT(DISTINCT a.FULL_NAME),
    'compliant_assets', COUNT(DISTINCT CASE WHEN NOT (
      EXISTS (
        SELECT 1
        FROM LATERAL FLATTEN(input => a.CATEGORIES) c2
        JOIN " + DB + ".DATA_GOVERNANCE.POLICIES p2
          ON UPPER(p2.FRAMEWORK)=UPPER(fw.NAME) AND UPPER(p2.CATEGORY)=c2.value::STRING
        WHERE (a.C < COALESCE(p2.MIN_CONFIDENTIALITY,0)
               OR (p2.REQUIRE_MASKING AND a.HAS_MASKING_POLICY=0)
               OR (p2.REQUIRE_ROW_ACCESS AND a.HAS_ROW_ACCESS_POLICY=0))
      )
    ) THEN a.FULL_NAME END),
    'non_compliant_assets', COUNT(DISTINCT CASE WHEN (
      EXISTS (
        SELECT 1
        FROM LATERAL FLATTEN(input => a.CATEGORIES) c3
        JOIN " + DB + ".DATA_GOVERNANCE.POLICIES p3
          ON UPPER(p3.FRAMEWORK)=UPPER(fw.NAME) AND UPPER(p3.CATEGORY)=c3.value::STRING
        WHERE (a.C < COALESCE(p3.MIN_CONFIDENTIALITY,0)
               OR (p3.REQUIRE_MASKING AND a.HAS_MASKING_POLICY=0)
               OR (p3.REQUIRE_ROW_ACCESS AND a.HAS_ROW_ACCESS_POLICY=0))
      )
    ) THEN a.FULL_NAME END)
  ) AS METRICS,
  NULL AS LOCATION
FROM APV a
JOIN " + DB + ".DATA_GOVERNANCE.FRAMEWORKS fw ON 1=1
GROUP BY fw.NAME`;
exec(insReports);

return 'OK';
$$;

-- TASK to run nightly at 02:00 Asia/Kolkata timezone
-- NOTE: Replace <WAREHOUSE_NAME> with a valid warehouse before enabling.
CREATE OR REPLACE TASK DATA_GOVERNANCE.TASK_GEN_DYNAMIC_COMPLIANCE
  WAREHOUSE = <WAREHOUSE_NAME>
  SCHEDULE = 'USING CRON 0 2 * * * Asia/Kolkata'
AS
  CALL DATA_GOVERNANCE.GEN_DYNAMIC_COMPLIANCE_REPORTS();

-- To enable the task after setting the warehouse:
-- ALTER TASK DATA_GOVERNANCE.TASK_GEN_DYNAMIC_COMPLIANCE RESUME;
